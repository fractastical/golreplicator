<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conway's Game of Life - Multidimensional</title>
    <style>
        canvas {
            border: 1px solid black;
            position: absolute;
            top: 0;
            left: 0;
        }
        #gameCanvas {
            z-index: 1;
        }
        #dimensionCanvas {
            z-index: 2;
        }
        #thirdDimensionCanvas {
            z-index: 3;
        }
        #controls {
            display: none;
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 4;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="500" height="500"></canvas>
    <canvas id="dimensionCanvas" width="500" height="500"></canvas>
    <canvas id="thirdDimensionCanvas" width="500" height="500"></canvas>
    
    <div id="controls">
        <button onclick="addPattern('glider')">Add a Glider</button>
        <button onclick="addPattern('blinker')">Add a Blinker</button>
        <button onclick="addPattern('toad')">Add a Toad</button>
        <button onclick="addPattern('beacon')">Add a Beacon</button>
        <button onclick="addPattern('spaceship')">Add a Spaceship</button>
        <button onclick="increasePropagation()">Increase Propagation Rate</button>
        <button onclick="increaseLifespan()">Increase Lifespan</button>
        <button onclick="switchDimension()">Switch Dimension</button>
    </div>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const dimensionCanvas = document.getElementById('dimensionCanvas');
        const dimensionCtx = dimensionCanvas.getContext('2d');
        const thirdCanvas = document.getElementById('thirdDimensionCanvas');
        const thirdCtx = thirdCanvas.getContext('2d');
        
        const gridWidth = 50;
        const gridHeight = 50;
        const cellSize = canvas.width / gridWidth;
        
        let grid = createGrid();
        let dimensionGrid = createGrid();
        let thirdDimensionGrid = createGrid();
        let steps = 0;
        let propagationRate = 100; // Speed of evolution
        let lifespan = 20; // Steps between evolutionary options
        let interval;
        let activeDimension = 1; // Track which dimension is active: 1 = original, 2 = second, 3 = third

        // GOL Patterns
        const patterns = {
            glider: [[0, 1], [1, 2], [2, 0], [2, 1], [2, 2]],
            blinker: [[0, 1], [1, 1], [2, 1]],
            toad: [[1, 0], [1, 1], [1, 2], [2, 1], [2, 2], [2, 3]],
            beacon: [[0, 0], [0, 1], [1, 0], [1, 1], [2, 2], [2, 3], [3, 2], [3, 3]],
            spaceship: [[0, 1], [0, 2], [0, 3], [1, 0], [1, 3], [2, 3], [3, 0], [3, 2]]
        };

        function createGrid() {
            let arr = new Array(gridHeight);
            for (let y = 0; y < gridHeight; y++) {
                arr[y] = new Array(gridWidth).fill(0);
            }
            return arr;
        }

        function drawGrid(grid, context, color) {
            context.clearRect(0, 0, canvas.width, canvas.height);
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    context.fillStyle = grid[y][x] === 1 ? color : 'white';
                    context.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
        }

        function nextGeneration(grid) {
            const newGrid = createGrid();
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const neighbors = countNeighbors(grid, x, y);
                    if (grid[y][x] === 1) {
                        newGrid[y][x] = (neighbors === 2 || neighbors === 3) ? 1 : 0;
                    } else {
                        newGrid[y][x] = neighbors === 3 ? 1 : 0;
                    }
                }
            }
            return newGrid;
        }

        function countNeighbors(grid, x, y) {
            let sum = 0;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    const col = (x + i + gridWidth) % gridWidth;
                    const row = (y + j + gridHeight) % gridHeight;
                    sum += grid[row][col];
                }
            }
            sum -= grid[y][x];
            return sum;
        }

        function stepGame() {
            if (activeDimension === 1) {
                grid = nextGeneration(grid);
                drawGrid(grid, ctx, 'black');
            } else if (activeDimension === 2) {
                dimensionGrid = nextGeneration(dimensionGrid);
                drawGrid(dimensionGrid, dimensionCtx, 'lightblue');
            } else if (activeDimension === 3) {
                thirdDimensionGrid = nextGeneration(thirdDimensionGrid);
                drawGrid(thirdDimensionGrid, thirdCtx, 'lightpurple');
            }
            steps++;
            if (steps % lifespan === 0) {
                pauseGame();
                document.getElementById('controls').style.display = 'block';
            }
        }

        function startGame() {
            interval = setInterval(stepGame, propagationRate);
        }

        function pauseGame() {
            clearInterval(interval);
        }

        // Function to randomly place a pattern on the grid
        function addPattern(patternName) {
            document.getElementById('controls').style.display = 'none';
            const pattern = patterns[patternName];
            const randX = Math.floor(Math.random() * (gridWidth - 5));
            const randY = Math.floor(Math.random() * (gridHeight - 5));
            
            if (activeDimension === 1) {
                pattern.forEach(([dx, dy]) => {
                    grid[(randY + dy) % gridHeight][(randX + dx) % gridWidth] = 1;
                });
            } else if (activeDimension === 2) {
                pattern.forEach(([dx, dy]) => {
                    dimensionGrid[(randY + dy) % gridHeight][(randX + dx) % gridWidth] = 1;
                });
            } else if (activeDimension === 3) {
                pattern.forEach(([dx, dy]) => {
                    thirdDimensionGrid[(randY + dy) % gridHeight][(randX + dx) % gridWidth] = 1;
                });
            }
            startGame();
        }

        function increasePropagation() {
            document.getElementById('controls').style.display = 'none';
            propagationRate = Math.max(50, propagationRate - 20); // Increase speed
            startGame();
        }

        function increaseLifespan() {
            document.getElementById('controls').style.display = 'none';
            lifespan += 5; // Increase time between evolutionary steps
            startGame();
        }

        // Switch dimension and handle transparency
        function switchDimension() {
            document.getElementById('controls').style.display = 'none';
            activeDimension = (activeDimension % 3) + 1; // Cycle between 1, 2, 3

            if (activeDimension === 1) {
                canvas.style.opacity = "1";
                dimensionCanvas.style.opacity = "0.2";
                thirdCanvas.style.opacity = "0.2";
            } else if (activeDimension === 2) {
                dimensionCanvas.style.opacity = "1";
                canvas.style.opacity = "0.2";
                thirdCanvas.style.opacity = "0.2";
            } else if (activeDimension === 3) {
                thirdCanvas.style.opacity = "1";
                canvas.style.opacity = "0.2";
                dimensionCanvas.style.opacity = "0.2";
            }
            startGame();
        }

        grid[24][24] = 1; // Seed the grid with a single live cell
        drawGrid(grid, ctx, 'black');
        startGame();
    </script>
</body>
</html>
